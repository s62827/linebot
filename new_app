from flask import Flask, request, abort
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import MessageEvent, TextMessage, TextSendMessage, ImageSendMessage

from supabase import create_client, Client

from datetime import datetime
import re
import matplotlib.pyplot as plt
import io
import os
from matplotlib import font_manager

# Supabase è¨­å®š
SUPABASE_URL = "https://kounvedczvpdiajozfkq.supabase.co"
SUPABASE_KEY = "ä½ çš„ Supabase Key"
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# LINE è¨­å®š
app = Flask(__name__)
LINE_CHANNEL_ACCESS_TOKEN = "ä½ çš„ LINE TOKEN"
LINE_CHANNEL_SECRET = "ä½ çš„ LINE SECRET"
line_bot_api = LineBotApi(LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

# é¡åˆ¥é—œéµå­—
category_keywords = {
    "é£²é£Ÿ": ["æ—©é¤", "åˆé¤", "æ™šé¤", "æ‹‰éºµ", "ç«é‹", "çå¥¶", "é£²æ–™", "åƒé£¯", "é¤", "éº¥ç•¶å‹"],
    "äº¤é€š": ["æ·é‹", "å…¬è»Š", "ç«è»Š", "é«˜éµ", "åŠ æ²¹", "åœè»Šè²»", "è¨ˆç¨‹è»Š", "uber", "é¨è»Š", "è»Šç¥¨"],
    "å¨›æ¨‚": ["é›»å½±", "éŠæˆ²", "Netflix", "æ¼”å”±æœƒ", "KTV", "ç›´æ’­", "YouTube", "æ¼«ç•«", "æ¡ŒéŠ"],
    "è³¼ç‰©": ["è¦çš®", "momo", "PChome", "æ·˜å¯¶", "å…¨è¯", "å®¶æ¨‚ç¦", "è¡£æœ", "åŒ…åŒ…", "é‹å­", "é›»è…¦"],
    "å…¶ä»–": []
}

# åŠŸèƒ½é—œéµå­—åµæ¸¬
def detect_function(text):
    function_keywords = {
        "æŸ¥è©¢": ["æŸ¥è©¢", "ç´€éŒ„", "çœ‹çœ‹å¸³"],
        "åˆªé™¤": ["åˆªé™¤", "ç§»é™¤"],
        "è¨­å®šé ç®—": ["è¨­å®šé ç®—", "é€™å€‹æœˆé ç®—"],
        "çµ±è¨ˆ": ["çµ±è¨ˆ", "ç¸½èŠ±è²»"],
        "æŸ¥è©¢æ—¥æœŸ": ["æŸ¥è©¢æ—¥æœŸ", "æ—¥æœŸ"],
        "åœ–è¡¨": ["åœ–è¡¨", "é¤…åœ–"],
        "æœ¬æœˆå‰©é¤˜": ["å‰©é¤˜", "å‰©å¤šå°‘", "é ç®—"]
    }
    for func, keywords in function_keywords.items():
        for kw in keywords:
            if kw in text:
                return func
    return None

# åˆ†é¡é‚è¼¯
def classify(text):
    for cat, keywords in category_keywords.items():
        if any(k in text for k in keywords):
            return cat
    return "å…¶ä»–"

# æå–å‚™è¨»èˆ‡é‡‘é¡
def extract_note_and_amount(text):
    match = re.search(r"([^\d\s]{1,10})?[^\d]*(\d{1,5})", text)
    if match:
        note = match.group(1) if match.group(1) else "æœªåˆ†é¡"
        amount = int(match.group(2))
        return note, amount
    return None, None

# Webhook è·¯ç”±
@app.route("/webhook", methods=["POST"])
def webhook():
    signature = request.headers["X-Line-Signature"]
    body = request.get_data(as_text=True)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)
    return "OK"

# è™•ç†ä¾†è‡ª LINE çš„è¨Šæ¯
@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    text = event.message.text.strip()
    user_id = event.source.user_id
    detected_func = detect_function(text)
    reply = ""

    # æŸ¥è©¢æœ€è¿‘ç´€éŒ„
    if detected_func == "æŸ¥è©¢":
        res = supabase.table("records").select("*").eq("user_id", user_id).order("id", desc=True).limit(5).execute()
        rows = res.data
        reply = "ğŸ“‹ æœ€è¿‘ç´€éŒ„ï¼š\n" + "\n".join([f"ID:{r['id']}ï½œ{r['date']}ï½œ{r['note']}ï½œ{r['amount']}å…ƒï½œ{r['category']}" for r in rows]) if rows else "ğŸ“­ æ²’æœ‰ä»»ä½•è¨˜éŒ„"

    # åˆªé™¤ç´€éŒ„
    elif detected_func == "åˆªé™¤" and text.startswith("åˆªé™¤"):
        try:
            target_id = int(text.split()[1])
            res = supabase.table("records").select("*").eq("id", target_id).eq("user_id", user_id).execute()
            if res.data:
                supabase.table("records").delete().eq("id", target_id).execute()
                reply = f"ğŸ—‘ï¸ å·²åˆªé™¤ï¼šID:{res.data[0]['id']}ï½œ{res.data[0]['note']}ï½œ{res.data[0]['amount']}å…ƒ"
            else:
                reply = f"âŒ æ‰¾ä¸åˆ° ID ç‚º {target_id} çš„ç´€éŒ„"
        except:
            reply = "âš ï¸ è«‹è¼¸å…¥ï¼šåˆªé™¤ [ID]ï¼Œä¾‹å¦‚ï¼šåˆªé™¤ 3"

    # æŸ¥è©¢åˆ†é¡
    elif text.startswith("æŸ¥è©¢ "):
        category = text.split()[1]
        res = supabase.table("records").select("*").eq("category", category).eq("user_id", user_id).order("id", desc=True).limit(5).execute()
        rows = res.data
        reply = f"ğŸ“‹ æœ€è¿‘çš„ã€{category}ã€‘ç´€éŒ„ï¼š\n" + "\n".join([f"ID:{r['id']}ï½œ{r['date']}ï½œ{r['note']}ï½œ{r['amount']}å…ƒ" for r in rows]) if rows else f"ğŸ“­ æ²’æœ‰åˆ†é¡ã€{category}ã€‘ç´€éŒ„"

    # çµ±è¨ˆåˆ†é¡ç¸½é¡
    elif detected_func == "çµ±è¨ˆ":
        res = supabase.table("records").select("category, amount").eq("user_id", user_id).execute()
        summary = {}
        for r in res.data:
            summary[r["category"]] = summary.get(r["category"], 0) + r["amount"]
        reply = "ğŸ“Š å„åˆ†é¡ç¸½èŠ±è²»ï¼š\n" + "\n".join([f"{k}ï¼š{v} å…ƒ" for k, v in summary.items()]) if summary else "ğŸ“­ æ²’æœ‰è¨˜éŒ„å¯ä»¥çµ±è¨ˆ"

    # æŸ¥è©¢æ—¥æœŸå€é–“
    elif detected_func == "æŸ¥è©¢æ—¥æœŸ" and text.startswith("æŸ¥è©¢æ—¥æœŸ"):
        try:
            _, start_date, end_date = text.split()
            res = supabase.table("records").select("*").eq("user_id", user_id).gte("date", start_date).lte("date", end_date).execute()
            rows = res.data
            reply = f"ğŸ“… {start_date}ï½{end_date} ç´€éŒ„ï¼š\n" + "\n".join([f"ID:{r['id']}ï½œ{r['date']}ï½œ{r['note']}ï½œ{r['amount']}å…ƒ" for r in rows]) if rows else "ğŸ“­ æ­¤å€é–“ç„¡è¨˜éŒ„"
        except:
            reply = "âš ï¸ æ ¼å¼éŒ¯èª¤ï¼Œè«‹è¼¸å…¥ï¼šæŸ¥è©¢æ—¥æœŸ 2025-04-01 2025-04-30"

    # ç•«åœ–è¡¨
    elif detected_func == "åœ–è¡¨":
        now_month = datetime.now().strftime("%Y-%m")
        res = supabase.table("records").select("category, amount").eq("user_id", user_id).like("date", f"{now_month}%").execute()
        rows = res.data
        if not rows:
            reply = "ğŸ“­ æœ¬æœˆå°šç„¡è¨˜éŒ„"
        else:
            summary = {}
            for r in rows:
                summary[r["category"]] = summary.get(r["category"], 0) + r["amount"]
            labels = list(summary.keys())
            values = list(summary.values())

            font_path = "NotoSansTC-VariableFont_wght.ttf"
            font_prop = font_manager.FontProperties(fname=font_path)
            plt.rcParams['font.family'] = font_prop.get_name()
            plt.figure(figsize=(6, 6))
            plt.pie(values, labels=labels, autopct=lambda p: f"{p:.1f}% ({int(p*sum(values)/100)}å…ƒ)")
            plt.title("æœ¬æœˆæ”¯å‡ºæ¯”ä¾‹", fontproperties=font_prop)
            buf = io.BytesIO()
            plt.savefig(buf, format='png')
            buf.seek(0)

            if not os.path.exists("static"):
                os.makedirs("static")
            with open("static/chart.png", "wb") as f:
                f.write(buf.read())
            buf.close()

            image_url = "https://ä½ çš„ç¶²å€/static/chart.png"  # â†è«‹æ›¿æ›æˆä½ çš„ç¶²å€
            line_bot_api.reply_message(
                event.reply_token,
                ImageSendMessage(original_content_url=image_url, preview_image_url=image_url)
            )
            return

    # è¨­å®šé ç®—
    elif detected_func == "è¨­å®šé ç®—":
        try:
            budget = int(text.split()[1])
            supabase.table("budget").upsert({"user_id": user_id, "amount": budget}).execute()
            reply = f"âœ… å·²è¨­å®šæœ¬æœˆé ç®—ç‚º {budget} å…ƒ"
        except:
            reply = "âš ï¸ æ ¼å¼éŒ¯èª¤ï¼Œè«‹è¼¸å…¥ï¼šè¨­å®šé ç®— 5000"

    # æŸ¥è©¢å‰©é¤˜é ç®—
    elif detected_func == "æœ¬æœˆå‰©é¤˜":
        budget_res = supabase.table("budget").select("amount").eq("user_id", user_id).execute()
        if not budget_res.data:
            reply = "âš ï¸ å°šæœªè¨­å®šé ç®—ï¼Œè«‹è¼¸å…¥ï¼šè¨­å®šé ç®— [é‡‘é¡]"
        else:
            budget = budget_res.data[0]['amount']
            this_month = datetime.now().strftime("%Y-%m")
            spent = sum(r['amount'] for r in supabase.table("records").select("amount").eq("user_id", user_id).like("date", f"{this_month}%").execute().data)
            reply = f"ğŸ’° æœ¬æœˆé ç®—ï¼š{budget} å…ƒ\nğŸ’¸ å·²èŠ±è²»ï¼š{spent} å…ƒ\nğŸŸ¢ å‰©é¤˜ï¼š{budget - spent} å…ƒ"

    # é è¨­ç‚ºè¨˜å¸³
    else:
        note, amount = extract_note_and_amount(text)
        if note and amount:
            category = classify(text)
            now = datetime.now().strftime("%Y-%m-%d")
            supabase.table("records").insert({
                "user_id": user_id,
                "date": now,
                "note": note,
                "amount": amount,
                "category": category
            }).execute()
            reply = f"âœ… å·²è¨˜å¸³ï¼š{note}ï½œ{amount} å…ƒï½œåˆ†é¡ï¼š{category}"
        else:
            reply = "âš ï¸ è«‹è¼¸å…¥é‡‘é¡æˆ–æœ‰æ•ˆæŒ‡ä»¤"

    line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply))
